package com.aclass.test.run;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Scanner;

public class TestRun {

	public static void main(String[] args) {
		
		// 오늘부터 쓸거많음
		// JDBC 맛보기 -> 이론 -> 코드짜기로 진행 예정
		// JDBC 맛보기
		/*
		 * 자바 배우고 DB 배웠는데, 얘넨 연관이 없음
		 * 회사가 같다 정도(오라클에서 관리하니까)
		 * DB를 배운 목적 : 자바에서 만들어낸 값을 저장장치에 저장하기 위해서
		 * 얘네를 같이 쓰는 방법을 학습해야 함 --> 그게 JDBC, JAVA DATABACE CONNECTIVITY
		 * 
		 * 놀랍게도 우리가 사용한 DBeaver는 자바를 이용해서 만든 프로그램
		 * 계속 자바로 만든 클라이언트 프로그램에서 DB에 작업하는 법을 학습했음
		 * 
		 * 어떤 절차로 작업했나? DB에 작업해야겠다면?
		 * 1. 디비버 실행(클라이언트 프로그램 실행), DB와 상호작용할수있는 클라이언트 프로그램을 동작시킴
		 * 처음에 어떻게 했는지 생각
		 * 
		 * 2. 접속하기 누름
		 * 디비버 왼쪽 위에 접속하는게 있었음
		 * 
		 * 3. DBMS 선택
		 * 접속하기 누르면 DBMS 뭐 쓸지 선택하라고 뜸, 그러고 next 눌러
		 * 
		 * 4. ojdbc.jar --> 등록 <- 이게 굉장히 중요! 오라클 전용 jdbc용 파일(정확히 표현하면 API)
		 * 그다음에 connect, 처음에 connect 안된 사람도 있음
		 * 이게 안되서 선생님한테 파일을 하나 받았음, 이걸로 등록하는 과정을 거치고 connection을 만들었음
		 * 
		 * 5. IP주소, PORT번호, 사용자계정, 비밀번호가지고 연결
		 * next 누르면 뭐나옴? DB서버와 연결하려고 네가지의 정보를 입력해야함
		 * 
		 * 6. 새 SQL편집기
		 * DB에 작업하고 싶으면? 이거 열어야함
		 * 
		 * 7. INSERT문 작성 ==> INSERT INTO 테이블명 VALUES('값', '값', '값');
		 * 이다음에 내가 하고싶은 작업을 하면 됨, 예를 들어서 이걸 한다고 가정해보자
		 * 
		 * 8. SQL문을 실행
		 * 일단 작성하고 나서 실행함
		 * 
		 * 9. UpdatedRows : 1
		 * 실행하고 나면 결과가 옴, INSERT문을 썼으니 추가가 됨
		 * 
		 * 10. COMMIT;
		 * 그럼 우리가 이걸 해야함
		 * 
		 * 1부터 10까지가 DB에 우리가 INSERT 한 행을 하기 위해 필요한 절차
		 * 이 절차는 죽었다 깨어나도 안바뀜, 방법이랑 도구는 계속 바뀜
		 * 이걸 1번부터 10번까지 순서대로 해야하는데, 기술, 언어, 도구에 따라서 이걸 하는 방법은 계속 바뀔 수 있음
		 * 이 절차(1행을 insert 하기 위해 필요한 순서 절차)는 안바뀜
		 * 내가 insert를 하기 위해서 지금 몇 번을 해야하는지 머리속으로 생각해야함
		 * 1부터 10까지 똑같이 할건데 이걸 자바코드로 작업할거임(디비버를 쓰는게 아니라)
		 * 이게 몇번이지? 이걸 생각해야해
		 * 세부적인 내용, 상세한 내용은 00번 프로젝트 끝나고 01번 프로젝트에서 설명하실 예정
		 * 일단은 시원하게 해보자!
		 * 
		 * 간단하게 insert 할거니까 실습을 간소화하기 위해서 간단한 테이블을 만들자(지금 너무 크고 복잡함)
		 * 
		 * 새 SQL 편집기 열러 ㄱㄱ
		 * 컬럼 세개정도 해서 작은 테이블 만들어보자
		 * 만들고 왔음
		 * 
		 */
		
		/*
		 * 자바로 코드상으로도 절차를 그대로 따라가야함
		 * 결국 하고자 하는건 출력, 여기서 만든 데이터를 밖으로 빼는것(데이터를 DB로 출력)
		 * 외부랑 연결되는 친구들이 생김, 스트림 역할을 하는 애들, 얘네는 마지막에 자원반납을 해줘야함
* 10:37 출력하는거니까 CHECKED EXCEPTION, 밖에서 어.. 하면 반납을 못하니까 앞에서 했던것처럼 미리 변수로 선언
		 * 
		 */
		
		// 0) 필요한 변수 세팅
		Connection conn = null; // 이친구는 2번 접속하기부터 5번까지
		
		// 6번부터 8번까지 역할을 할 친구가 필요함
		Statement stmt = null; // java.sql.Statement <-- import 이걸로
		
		// 나중에 실행결과를 받아주는 친구가 필요함(9번), 실행결과는 정수로 온다, 정수로 받아줄 친구니까 int로 선언
		int result = 0;
		
		// 이번에 하고싶은건 insert인데, 날짜는 sysdate 넣고 번호랑 이름은 사용자에게 입력받아서 insert 해보자
		// 사용자한테 값을 입력받고싶으면 스캐너가 있어야함
		// 사용자에게 값을 입력받아서 DBMS로 전달 => 테이블에 INSERT
		Scanner sc = new Scanner(System.in);
		
		// num, name, date가 있는데, date에는 sysdate 넣고 num이랑 name만
		System.out.print("번호를 입력해주세요 > ");
		int num = sc.nextInt();
		sc.nextLine();
		System.out.print("이름을 입력해주세요 > ");
		String name = sc.nextLine();
		
		// 실행할 SQL문 준비할건데, 미리 적어놓자면 완성된 형태로 만들어줘야함
		// 실행할 SQL문(완성된 형태로 만들어주기)
		// SQL문의 세미콜론은 안씀, 쓰면안됨, 나머지를 자바에서 써야함
		// 자바에서 얘(SQL문)는 문자열 데이터
		String sql = "INSERT INTO TB_STUDENT VALUES(1, '홍길동', SYSDATE)";
		
		// 우리가 쓰고싶은건 이게아님, 우리가 쓰고싶은건 어떻게 생긴 INSERT?
		// 1의 자리에 num이 들어가고, '홍길동'자리에 name이 들어간걸 쓰고싶음
		// 내가 리터럴로 적는게 아니고 사용자가 입력한 값을 넣어주고 싶음
		sql = "INSERT INTO TB_STUDENT VALUES(" + num/*1 자리에 사용자가 입력한 숫자가 들어가야함*/ + ", '" + name + "', SYSDATE)";
		
		// 여기까지가 준비단계
		
		// 이제 2. 접속하기 누름 해야함
		
		// 2, 3, 4, 5 할때 뭐가 필요함? 오라클에 접속하는거라서 오라클에 접속하기 위한 드라이버가 필요함
		// 자바 프로그램 안에서도 jdbc 드라이버를 등록하는 과정이 있어야함
		// 1) JDBC Driver 등록 -> ORACLE -> ojdbc.jar
		// Driver등록은 프로그램 실행 시 딱 1회만 하면됨
		// 자바의 리플렉션이라는 기술을 사용함, Class 클래스에 forName이라는 메소드가 존재함
		// 사용하려고 하는 메소드의 풀패키지명을 써준다
		try {
			
			Class.forName("oracle.jdbc.driver.OracleDriver");
			// 이 패키지에 존재하는 클래스를 등록하는 과정, 예외 발생할 수 있으니 CE는 예외처리구문 작업 해줘야함
			
			// 그래도 ClassNotFoundException 발생함
			/*
			 * 선생님의 그림판 ㄱㄱ
			 * 
			 * 자바를 이용해서 프로그램을 만들고있음
			 * 우리 말고도 수도없이 많은 자바개발자들이 프로그램을 만들고 이걸로 DB에 select, insert 작업들을 해야함
			 * 프로그램에서 DB에 입력하고 출력해야함, 이런 작업들을 해야하는데
			 * 문제가 뭐냐면, 프로그램과 DB는 상호간에 연관이 없음, 전혀 다른 얘기
			 * 자바라는 프로그래밍 언어를 쓰고있고 DB는 종류도 많고 지금도 계속 새로 나오고 있고
			 * 일반적으로 DBMS는 전부 프로그램으로 만들어진 데이터를 저장하기 위한 용도로 나오겠지
			 * DB들은 자기가 만든 DB를 언어를 통해서 사용할 수 있도록 만들어줘야함
			 * 세상에 DBMS 종류는 어마어마하게 많음, 밑도끝도없음
* 11:08 개발자들이 사용할 DB나 회사에서 계약한 DBMS는 전부 다르겠지
			 * 이 DBMS 전부 사용방법이랑 코드가 다르면? 개발자들 머리 터지겠지
			 * 자바 입장에서도 DBMS 만든애들이 다 다를텐데, 이걸 코드로 작성해서 사용할 수 있게 통일성있게 규칙을 만들어야함
			 * 자바 이용해서 DBMS 이용할 수 있게 하고싶어? 그럼 이 규칙에 맞게 클래스를 만들어와!
			 * 자바에서 규칙을 만드는 방법이 뭐가있음? DBMS 제조사들이 실제 클래스를 만들겠지, 근데 중구난방으로 만들어지면 안되고
			 * 모든 규격이 같아야함
			 * 자바에서 규칙을 만들어주는 방법이 뭐가있음? 인터페이스
			 * 너네 DBMS 회사들, 자바가지고 접속해서 만들거면 인터페이스 구현해서 만들어라, createStatement 구현해서 만들어
			 * 이러고 인터페이스로 만들어놓음
			 * 실제로 접속할 코드는 DBMS 제조사에서 만들어야함, 걔네가 알겠지
			 * 그럼 인터페이스로 구현하면 DBMS 회사들은...?
			 * 장점이뭐임? 이걸 이용해서 개발하는 개발자들은 실제 클래스가 어떻게 생겼는지 몰라도 상관없음
			 * 인터페이스라는 규격이 생겼기 때문에, 나는 그냥 createStatement만 쓰면 모든 DBMS를 똑같이 쓸 수 있음
			 * DB작업 절차는 같지만 사용하는 DBMS는 다 다르겠지만 모든 것을 똑같은 방법으로 사용할 수 있게끔 만들어준 API가 JDBC
			 * 인터페이스만 만들어주고 DBMS 만드는 회사들이 이걸 구현해서 제공해줘야함
			 * 
* 11:12 jar 파일이 뭐임?
			 * 
			 * ojdbc.jar는 오라클에서 만들어준건데
			 * 자바에서 만들어준 API를 구현한 클래스 파일들이 엄청 많이 생겼을텐데, 이걸 하나의 압축 파일로 묶어서 확장자가 jar라는 이름으로 제공됨
			 * 오라클 DBMS에 접속을 하기 위해서는 오라클 드라이버라는 클래스를 써야함(OracleDriver)
			 * 열어보면 깨져있겠지만 실제로는 이런식으로 만들어진 코드(JVM이 읽을 수 있는 형태로 변환이 되어서 나와있음)
			 * 이 안에 있는 클래스 파일을 프로그램을 실행하는 동안에 등록하는것
			 * 
			 * 이 파일을 우리가 등록을 안해줬기 때문에 프로젝트 안에서 찾을 수가 없어서 예외가 발생한것
			 * 
			 * 디비버 할때는 접속하려고 선생님이 주신것을 드라이버 세팅에서 등록했음
			 * 지금 자바에서는 이 과정이 없었음, 여기서도 등록을 해줘야함
			 * 무조건 이 절차에 써있는걸 다 해야만 insert도 할 수 있고 commit도 할 수 있음
			 * 나중에는 직접적으로 등록하지 않을텐데, 일반적으로 자바로 등록한다면?
			 * 프로젝트 파일 우클릭 -> properties 들어가서 작업
			 * 
			 * 패키지 익스플로러에서 referenced libraries -> oracle.jdbc.driver
			 * -> OracleDriver.class 얘를 등록해서 사용해야함
			 * 
			 */
			
			// 설명 듣고 나서 클래스 파일 등록하고 왔음
			System.out.println("Driver등록 성공!"); // 이거 출력되면 성공적
			
			// 아직 시작도 안함 디비버로 치면 add file 해서 파일 등록까지 한거임
			// 진짜로 데이터값 입력해서 DB서버랑 커넥션을 만들어내야함, 절차로 따지자면? 3번까지 한것임, 4번도 했음
			
			// 5번을 해야함, 아이디 포트 사용자계정 비번 적어서 연결하기
			
			// 2) DB서버와의 연결(IP주소, PORT번호, 사용자이름, 비밀번호)
			// 방금 등록한 오라클 드라이버로 연겨할 수 있음(드라이버 등록 안하면 연결할수없음)
			// 등록하고 나면 DriverManager클래스를 사용할 수 있음, import 해야함
			// 여기에 스태틱 메소드가 있음, 연결을 얻어내고 싶음, 내놔하고싶음 --> get!
			conn = DriverManager.getConnection("jdbc:oracle:thin:@115.90.212.20:10000:XE", "CJ18", "CJ181234");
			// getConnection 메소드 오버로딩이 잘되어있음, 문자열 url, 문자열 사용자, 문자열 비밀번호를 받는다고 되어있음
			// 문자열 인자값 3개를 넘겨줘야함
			// Unhandled exception type SQLException --> 셋다 잘못적을 가능성이 있음, 사람이 적는거니까 얼마든지 문제가 발생할 수 있는 일
			// 여기 하나라도 잘못되면 접속이 안되니까 외부와의 연결을 하는거니까 문제가 발생할 수 있음
			// 예외처리 해줘야겠는데? 하는거지 --> 반드시 SQLException에 대한 예외처리를 해줘야함 --> catch 구문 추가
			
// 11:35 IP주소와 PORT번호는 URL로 합쳐졌는데, DBMS에 따라 적는 방법이 다름, 사이트에 가면 제조사에서 만들어주는거라서(제조사에서 만든 규칙)
			// 지금 쓰고있는 오라클 18c버전이라서
			// "URL", "사용자이름", "비밀번호" 수정
			// URL --> jdbc:oracle:thin:@IP주소:포트번호
			// 우리 IP주소는? 115.90.212.90
			// 포트번호는 10000
			// "jdbc:oracle:thin:@115.90.212.20:10000" 이건 과정 끝날 때 까지 안바뀌는 상수값
			// 사용자이름이랑 비밀번호는 내거
// 11:38 이름은 소문자로 작성해도 오라클 서버가 대문자로 바꿔줌, 등록할 때 대문자로밖에 등록이 안됨
			// 비밀번호는 대소문자를 구분함, 항상 대소문자를 명확하게 구분해서 작성해야함
			// 접속할때도 오타나서 잘못될수있겠지...?
			System.out.println("DB서버 접속 성공!");
// 11:41 URL 마지막에 :XE 추가해줌
			
			// 오토커밋 안할래 여기서 설정해야함
			conn.setAutoCommit(false); // 이러면 얘가 오토커밋 안해주고 우리가 직접 커밋해야함
			
// 이건 Connection 객체로 해야함?
			// 메소드 이름이 getConnection이었음, 메소드 반환타입이 Connection임, 메소드호출 반환값을 어디 대입해?
			// 0에서 만들어둔 변수 conn에 담아주면 됨 --> conn = DriveManager로 수정
			
			// 3) 새 SQL 편집기 열기
			// Statement가 역할을 함, 연결해야 SQL편집기를 열 수 있음
// 여기도 커넥션이 생겨야 열 수 있음?
			// 커넥션에 메소드가 있음
			stmt = conn.createStatement(); // 객체를 반환해주는데 미리 변수로 선언해둔 것으로 받아줌
			System.out.println("Statement 객체 생성!");
			
			// 아까 1번부터 10번까지 절차 생각해보면 6의 새 SQL 편집기 열기 까지 했다!
			// 7번은 아까 미리 해놨음
			// 8번 해야겠다! SQL문 실행해야겠네
			// 4) SQL문 실행
			// stmt <-- 얘 가지고함, 메소드 호출해서 하는데 메소드 중에 executeUpdate
			result = stmt.executeUpdate(sql); // "실행하고자하는 SQL문"을 인자로 전달, 위에서 변수에다가 대입해놨음
			// 이대로 실행하면 SQLSyntaxErrorException
			// SQL INSERT문 아까처럼 쓸 수 없음, name이 문자열 데이터니까 앞뒤로 홑따옴표 붙여줘야함
			// sql 변수에 홑따옴표 넣어서 수정하고 다시 실행하면 무소식이 희소식
			
			// 무결성 제약 조건 위배 --> 같은 번호 입력했으면 발생함
			// 내가 지금 넣으려는 값이 어떤 값인지 생각해야함
			// 표를 만들면서 PRIMARY KEY 지정한 컬럼은 널값, 중복값 넣을 수 없음(제약조건 위배)
			// 자바만 하는 것도 아니고 DB만 하는 것도 아님, 두개를 유기적으로 사용하고 있으므로 코드가 아니라 흐름을 생각해야함
			System.out.println("SQL문 실행 성공!");
			
			// 이제 사용자에게 입력받은 값을 INSERT했음
			// 여기서 확인은 안됨(오후에 할거임) --> 디비버에서 확인해보면됨
			
			// 이제 몇번까지 한거임? 8번까지 한거임!
			// 커밋해야하는데 얘도 오토커밋... 지알아서 커밋함
			// 우리가 직접 하고싶음, 개발자니까 커밋의 맛을 느껴보고싶다
			// 근데 커밋의 맛 하려면 DB서버 접속 성공 다음에 끊어야함
			// 올라가서 작성함
			
			// 성공했을 때 커밋해야하는데? 성공실패 기준은?
			// DML 했을 때 insert하면 결과가 어떻게 돌아옴?
			// UpdatedRows : N
			// 업데이트하면 결과가 어떻게 돌아옴? 똑같이 옴
			// UpdatedRows : N
			// delete해도 똑같이 옴
			// UpdatedRows : N
			// DML(INSERT, UPDATE, DELETE) => 처리된 행의 개수
			// 이거랑 마찬가지로 우리가 메소드를 호출하면서 dml문을 보냈음, 반환타입을 보면? int임
			// executeUpdate(DML문); : int
			// 조작이 된 행이 실수일리는 없지, 1.1행일리가 없음, 정수가 올것임, 이거 받으려고 변수 선언 해뒀으니까 수정
			// result = stmt.executeUpdate(sql);
			// 이제 이거 보면 성공했는지 실패했는지 알 수 있게 됨, 결과 보고 성공했을때만 커밋해주고싶음 --> 조건!
			
			// 5) 트랜잭션처리
			if(result > 0) { // INSERT에 성공했을 경우(성공했을 때만)
// 12:23 실패했을때는 필요없음
				
				conn.commit(); // 성공했을 때만 커밋해줄건데 커밋은 커넥션이 갖고있음
				
			}
			
			// 여기서 메인메소드 호출하는게 1의 디비버 실행이랑 같지
			// 2, 3, 4는 우리로 따지면 Class.forName
			// 5는 4개 써서 연결하는데 여기서는 conn = Driver ~
// 12:25 6 새편집기 열기는 3) 의 conn.
// 재생버튼 눌러서 실행하는건? stmt.executeUpdate(); 이게 DB서버에 요청하는거고
// 이게 끝나면 확정지어야겠다면 커밋하는데 이걸 코드에서는 conn.commit();
			// 절차를 코드로 풀어냄
			
			// 여기까지는 JDBC 절차고, 이제 자바상의 절차를 해줘야함 --> 자원반납 --> finally에서
			
		} catch(ClassNotFoundException e) {
			
			e.printStackTrace(); // 프로젝트에 OJDBC추가했나요?
			// 추가했다면 오타난거임, 무조건!!! 무조건!!!
			System.out.println("무조건 Class.forName(\"oracle.jdbc.driver.OracleDriver\"); <-- 얘가 문제임");
			// 무조건 여기 확인하면 됨, 이친구 아니면 이 예외가 일어나지 않음, 정답이 정해진 문제
			
		} catch(SQLException e) {
			
			e.printStackTrace();
			System.out.println("사용자이름/비밀번호가 잘못됐습니다. -> 무조건 conn = DriverManager.getConnection(\"jdbc:oracle:thin:@115.90.212.20:10000:XE\", \"CJ18\", \"CJ181234\"); 이 안의 아이디, 비밀번호가 잘못된것임!");
			System.out.println("부적합한 Oracl URL이 지정되었습니다 -> 무조건 conn = DriverManager.getConnection(\"jdbc:oracle:thin:@115.90.212.20:10000:XE\", \"CJ18\", \"CJ181234\"); 안의 URL 잘못쓴것");
			System.out.println("SQLSyntaxErrorException -> SQL문 확인하기"); // 이것도 볼것도 없이 무조건 실행할 SQL문 잘못쓴것, 그 외에는 이 예외가 나올 수 없음
			System.out.println("NullPointerException -> JDBC객체들 확인하기"); // 너무나도 많은 곳에서 일어날 수 있음, 우리가 코드가 익숙하지 않으니까 이런거 빼먹을 수 있음(호출하고 반환받는거)
			// conn, stmt 이런거 선언해서 메소드 호출값 반환받지 않으면 그다음에 메소드 호출할 때 NullPointerException 발생함, 안그럼 계속 null
			
		} finally { // 자원반납은 생성의 역순
			
			try {
				
				stmt.close();
				conn.close();
				
			} catch(SQLException e) {
				e.printStackTrace();
			}
			
		}
		
		// 여기서 다 풀어서 모든 기능을 다 구현하고 있음, JDBC가 어떻게 동작하는지 알아보자 해서..
		// 실제로는 이렇게 안함, 만약에 클래스를 구분해서 들어간다면 얘는 어디 클래스에 들어가야함? 이 작업이 무슨 작업임? DB와의 입출력이니까 클래스는?
		// 뷰는 사용자와의 입출력이고, 얘는 DAO에 들어가야함, DAO의 하나의 메소드가 이걸 가지고 있어야함
		// 실제로 프로젝트 할 때 DAO는 이렇게 안생겼음
		// 겁나 짧네 ㅎ 근데 짧게 써도 어떻게 동작하는지 알아야하니까 이렇게 하고 있음, 짧게 썼지만 실제로는 이렇게 돈다는 JDBC의 원리 이해
		
		// 문제가 발생할텐데 각 문제가 왜 생기고 어떻게 해결하는지 알아보자
		
		// 실수 많이 하는 부분이 String 상수값 적는 부분
		// 프로그램을 동작시켰더니 ClassNotFoundException이 발생함, 이러면 catch로 들어가겠지?
		// 얘는 누가 문제임? 무조건 Class.forName("oracle.jdbc.driver.OracleDriver"); <-- 얘가 문제임
		// 이게 출력되는 이유는 두가지
		// 첫번째는 프로젝트에 ojdbc 추가를 안했다거나 두번째는 오타났거나
		
		// 만약에 디비버를 가지고 DBMS에 접속을하는데 사용자 계정명을 잘못쓸수있음
		// 이렇게 하고 접속하려면 사용자명/비밀번호가 부적합, 로그온할 수 없습니다
		// 이건 DB서버의 응답임(중요!), 인증할래 하고 요청했더니 아닌데 하고 응답해준것
		// 코드상에서도 똑같음, 요청을 보내는것임
		// 내가 DB접속할 때 사용자 아이디랑 비밀번호를 잘못 적었다는 이야기임
		// 코드상에 적는 곳은 getConnection메소드의 두번째, 세번째 인자값임
		// 예외가 사용자명/비밀번호가 부적합, 로그온할 수 없습니다. 라고 뜨면 여기로 가면됨
		
		// 사용자 계정이랑 비밀번호는 잘 쓰고 URL을 잘못쓸 수 있음
		// : <-- 이런거 빼먹을 수 있음
		// 이거 빼먹으면 부적합한 Oracle URL이 지정되었습니다 라고 뜸, 이건 DBMS 제조사에서 못박아놓고 쓰는것, 제대로 썼냐 안썼냐를 검증함
		// 이 예외가 발생한다면? 무조건 URL 작성부가 잘못된것
		// ip를 잘못 적으면 아예 다른 컴퓨터한테 간다는 뜻이니까 같은 메세지가 뜸
		
		// 아까 우리가 겪은 문제 SQLSyntaxErrorException
		// 이것도 무조건 SQL문 잘못 쓴 것!
		
		// NullPointerException
		// 이건 객체에 주소값 안담겨있어서 --> 내가 변수 선언하고 반환되는 것을 받아줘야하는데 안해서
		
		// 문제가 발생했는데 그걸 예측하려고 하면 안됨
		// 문제의 원인을 파악해야하는데 머리속으로 상상하는게 아니라 나와있는 결과를 보고 찾아가는것(컴퓨터가 알려주는대로)
		// 내 주관을 넣으면 안됨, 그럼 운으로 찍어맞추는거고 실력이 늘지 않음
// 12:49 명확하게 ... 하고 공부해야 실력이 는다!
		
		// 문제파악 원인찾고 해결방안생각해서 도입하는것까지 문제해결능력, 개발자라면 문제해결능력이 필요하지
		// 잘썼으면 문제가 일어날리없지, 무조건 뭐가 잘못됐으니까 일어남. 고치고 나서 돌아가니까 됐다 이러는게 중요한게 아니라 왜 안돌아갔는지가 중요함
		// 결과보다는 과정이 중요하지. 과정이 올바르게 잘 되면 결과는 잘 나오겠지
		
	}

}
