<?xml version="1.0" encoding="UTF-8"?>
<!-- 뭐 써야하지? 공식문서 보러감 -->
<!-- 첫줄은 xml 관련 인코딩 설정, DOCTYPE mapper는 매퍼파일이라는 뜻이고, .dtd는 유효성 검사해주는 코드, 이건 고대로 쓰는게 고정 -->
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!-- 11:13 아까는 최상위요소 언급, 얘의 최상위 요소는 mapper여야함, 전체가 mapper로 감싸져있어야함
마이바티스에서 쓰는 매퍼 xml은 기본적으로 이렇게 생김, 공식문서에 설명 잘 나와있음 -->
<mapper namespace="memberMapper"><!-- 여기에 속성을 하나 넣어서 다른 매퍼 파일과 구분 -->
<!-- namespace : 각 mapper의 고유한 별칭 다른 매퍼파일과 중복되면 안됨
다른 매퍼랑 겹치면 안됨, 충돌남, 구분하기 쉽게 파일명 따라 memberMapper
-->
	<!-- 경우에 따라 작성방식이 달라짐, 지금은 insert 쓰러옴, insert sql을 하나의 태그로 감싸줌
	 	* DML일 경우(각각의 이름을 딴 태그가 있음)(나중에 정수로 돌아감, 몇행인지)
	 	<insert id="각 SQL문의 식별자">
	 		쿼리문(내가 쓰고 싶은 쿼리문은 이 컨텐트 영역에 작성)
	 	</insert> 이 태그를 여러개 적을 수 있지만 각 insert틀 식별할 무언가가 필요함, 그건 id 속성
	 	
	 	<update></update>
	 	
	 	<delete></delete>
	 	
	 	* SELECT일 경우(뭘로 돌아갈 지 알 수 없음, 지금은 멤버들이 담긴 리스트지만 그냥 멤버로 갈 수도 있고, count를 했다면 정수가 돌아감, 나중에 돌아갈 형태가 전부 다름)
	 	이 안에 여러개 있을 수 있는 select를 식별할 무언가가 있어야함, id, 이 xml안에서는 겹치면 안됨, 다른 xml이면 상관없음
	 	<select id="각SQL문의 식별자" parameterType="SQL문을 실행할 때 필요한 자바타입"
	 	resultType="조회결과를 반환하는 자바타입" 또는
	 	resultMap="조회결과를 반환할 resultMap의 id속성값">
	 		쿼리문
	 	</select>
	 	
	 	=> parameterType은 전달받을 값이 없다면 생략이 가능함(필수속성이 아님)
	 	==> count(*) => 정수 / 중복체크 => 문자열
	 	=> SELECT문의 경우 반드시 어떤 형태로 반환할지를 속성으로 명시해야함(두개중에 하나는 반드시 적어야함, resultType/resultMap
	 	Map이 더 귀찮으니까 먼저 써보자>
	 	
	 	==> 그동안 pstmt 객체를 이용해서 ?를 썼지만,
	 	앞으로 위치홀더 대신 해당 SQL문에 전달된 객체로부터 값을 꺼내서 사용! => (우리가 실질적으로 쓰는 건 아닌데) 내부적으로는 getter호출!
	 	getter호출방법 == #{필드명 또는 변수명 또는 map의 키값}
	-->
	
	<insert id="save"
	parameterType="com.kh.statement.model.vo.Member"><!-- id는 안헷갈리려면 메소드명 똑같이 적는것이 좋겠다, 안에는 그냥 SQL문, parameterType에는 넘어온 객체의 풀클래스명 -->
		INSERT
		  INTO
		       MEMBER
		VALUES
		       (
		       SEQ_USERNO.NEXTVAL
		     , #{userId}<!-- 전달받은 멤버객체의 필드값이 들어가야함, #, 중괄호 열고닫고, 내가 게터로 호출하고 싶은 필드명을 적음, 이러면 알아서 필드명에 해당하는 필드를 찾아서 게터메소드를 호출해서 값을 뽑아다가 여기에 대입을 해줌 -->
		     , #{userPwd}
		     , #{userName}
		     , #{email}
		     , SYSDATE
		       )
	</insert>
	
	<!-- 
		* resultMap : 마이바티스에서 가장 중요하고 강력한 요소
					  ResultSet으로부터 조회한 컬럼의 값을 하나씩 뽑아서
					  우리가 만든 VO객체에 각 필드에 담는 JDBC코드를 줄여주는 역할 수행(지금 VO가 문제가 있어서 문제가 생길것임, 확인하고 수정하도록하자)
		이 작업을 줄여준다 ↓
		while(rset.next()) {
			Member member = new Member();
			member.setUserNo(rset.getInt("USERNO"));
			member.setUserId(rset.getString("USERID"));
			
			members.add(member);
		}
		
		mapper 안에 resultMap도 여러개 있을 수 있으니 식별할 id 속성,
		어떤 타입으로 매핑하고 싶은지 알아야 매핑해주니까 속성 하나 더 필요함
		<resultMap id="식별자" type="매핑하고자하는 자바객체의 타입(풀클래스명)">
		
			어떤컬럼의 값을 뽑아서 어떤 필드에 담겠다를 여기 써야함
			<result column="조회된 결과를 뽑고자하는 컬럼명" property="해당 결과를 매핑할 필드명" />
			
			예시)
			<result column="USERNO" property="userNo" />
			
		</resultMap>
	-->
	
	<!-- resultMap="memberResultSet" 이걸로 했던 작업 지금은 좀 낭비임, resultType을 수정함 -->
	<select id="findAll"
			resultType="com.kh.statement.model.vo.Member"><!-- 이방법은 컬럼명과 필드명을 맞춰뒀다면 마이바티스가 오토매핑을 함
			이러면 SQL문 한줄, DAO 한줄쓰면 끝, 반복해야 했던 코드 전부를 마이바티스가 대신해줌, 그 작업을 안할수는 없음, 어차피 해야하는데 중복코드 반복을 마이바티스가 대신해줌
			DAO가 띡 하면 끝, 절차는 사라지지 않는다 없으면 코드가 못돌아 그걸 마이바티스가 대신해주는것, 더 발전을 시킬 수 있음 -->
<!-- 헷갈리지 않도록 메소드 이름과 동일하게 식별자(id 속성값), 호출될 때 넘어온 파라미터가 없으므로 그냥 SQL문, 어떤 것으로 돌아갈지(반환) resultMap속성(id)을 적어줌 -->
		SELECT
		       USERNO<!-- 이 컬럼값을 member의 userNo 필드에 담고싶음 -->
		     , USERID
		     , USERPWD
		     , USERNAME
		     , EMAIL
		     , ENROLLDATE
		  FROM
		       MEMBER
		 ORDER
		    BY
		       ENROLLDATE DESC
	</select>
	
	<!-- 어떤 컬럼에서 값을 뽑을지는 column에 작성, 뽑은 값을 어느 필드에 넣을건지는 property에 작성, 이 코드가 while부분을 대체함 -->
	<!-- 재활용이 되고 가시적이됨(한눈에 알아보기 쉬움), resultMap의 진정한 장점은 이게 아니긴하지만 일단 한번 써봄 -->
	<resultMap id="memberResultSet"
			   type="com.kh.statement.model.vo.Member">
	
		<result column="USERNO" property="userNo" />
		<result column="USERID" property="userId" />
		<result column="USERPWD" property="userPwd" />
		<result column="USERNAME" property="userName" />
		<result column="EMAIL" property="email" />
		<result column="ENROLLDATE" property="enrollDate" />
		
	</resultMap>
	
	<!-- select 구분을 위해 id 속성(속성값)을 작성함, 밖에있는것과 헷갈리면 안되니까 메소드명을 똑같이(대소문자 구분)
	속성 두개 더 적어줘야함, 메소드 호출할 때 인자를 전달받음, 코드상으로 넘긴거고 이친구 입장에서는 받아온게 무슨타입인지 모름, 이걸 매개변수로 받아온거니까 parameterType에 적음
	-->
	<!-- 자료형은 별칭이 지정되어있음, 공식문서(모든 마이바티스를 쓰는 자바개발자의 공식 매뉴얼)에서 확인가능, String이라고 써도 잘 돌아가고 안써도 돌아감(똑똑하네), 그래도 나와있는걸 잘 지켜주는게 좋다 -->
	<!-- 많이쓰는거 실무에서 자주 쓰는건 선생님이 알려주실테니 최소한 수업시간에 하는건 다 알아야함 -->
	<!-- SELECT는 나중에 반환을 어떻게 할 지 반드시 적어줘야함 -->
	<select id="findById"
			parameterType="string"
			resultType="com.kh.statement.model.vo.Member">
		SELECT
		       USERNO
		     , USERID
		     , USERPWD
		     , USERNAME
		     , EMAIL
		     , ENROLLDATE
		  FROM
		       MEMBER
		 WHERE
		       USERID = #{userId}
    <!-- 원래 해야했던 작업을 마이바티스가 대신하도록 위치홀더를 바꿔줌, 아까는 멤버를 받았으니 필드명을 적어줌, 지금은 문자열값 하나만 받았음, 보편적으로는 넘어온 친구 변수명과 똑같이 적음 -->
    <!-- 왜 보편적으로 라고 설명하는지는 조금이따가 -->
    <!-- 이부분은 웬만하면 넘어온 변수명과 맞춰주는 편이라고 하셨음, 안 맞춰주고 그냥 맘대로 썼다면? 결과가 잘 나오긴 함, 꼭 맞춰야지만 잘 나오는 건 아님
    이건 조건이 있음, DAO 넘어가기 전에 넘겨야 할 값이 2개 이상이면 반드시 데이터를 가공해서 어느 하나에 담아서 넘어가야한다고 했음, 꼭 해줘야한다고 하셨음
    그 이유를 이제 설명할 수 있게 됨, sql 실행할 때 필요한 값이 여러개일 수 있음, 마이바티스를 할 때 넘길 수 있는 인자값이 하나밖에 없음(무슨 SQL문을 쓰든 메소드 호출할 때), 파라미터 받아주는게 하나밖에 없음
    마이바티스를 쓰면 어쩔 수 없이 메소드를 호출할 때 하나에 담아서 넘겨줘야함
    DAO는 데이터 가공하는 곳이 아님, 여기 오기 전에 해와야함, 얘는 받아서 넘기는것만 해야함, 무조건 하나로
    이런것들을 앞에서는 설명할? 설명 하면 하지만 알아듣냐 마냐가 다른문제. 그때는 이렇게 해야합니다 하고 나중에 이걸 사용할 때 요래서 앞에서 그렇게 했습니다 하고 설명하시는 편
    member 객체는 VO로 담았으니 안에 여러개가 들어있을 수 있음, String은 값이 하나(userId)
    마이바티스 입장에서는 어차피 하나밖에 못받기 때문에 매개변수 이름으로 안맞추고 아무거나 적어도 넣을 게 String값이 될 수 밖에 없음, 그래서 이걸 알아서(넘어온걸 그냥) 마이바티스가 넣어버린 것, 그냥 넣었는데 운좋게 맞아떨어져서 돌아갔겠지?
    하지만 사람이 봤을 때 아무거나 적어뒀다면 뭔지 모르니까 맞춰서 적어줌
    -->
	</select>
	
	<!-- 풀클래스명 사용할 때 오타를 줄이는 방법 : 별칭을 붙여서 짧게 사용할 수 있음, 모르니까 공식문서 가보자, typeAliases -->
	<!-- 안에서 계속 쓸거니까 config 파일에서 함, 위치 중요함!! -->
	
	<!-- 간혹 메소드명과 아이디속성값이 달라질 수 있음, DAO가 오버로딩된 메소드를 가지면 달라질 수 있지만 그런 경우는 잘 없음 -->
<!-- ??? 속성값 두개 필요함, 넘어오는 매개변수는 Object니까 마이바티스는 뭐인지 알수없음, resultMap/resultType 둘중에 하나는 무조건 적어야함, 맵은 필요할때만 쓰고(강력하긴하지만쓸데없고지금단순해서그냥한번해봄) 지금은 resultType, 원래 풀클래스명 썼지만 지금은 alias 쓰면됨 -->
	<select id="findByKeyword"
			parameterType="string"
			resultType="member">
		SELECT
		       USERNO
		     , USERID
		     , USERPWD
		     , USERNAME
		     , EMAIL
		     , ENROLLDATE
		  FROM
		       MEMBER
		 WHERE
		       USERID LIKE '%' || #{keyword} || '%'
	</select><!-- DAO에서 키워드 넘길때 문자열 합쳐도 되지만 여기서 하는게 낫지 -->
	
	<!-- update문 쓸거니까 update태그, 각 update문을 구분하기 위해 id 속성 작성, 파라미터 별칭 안짓고와서 그냥 풀클래스명 작성 -->
	<update id="update"
			parameterType="com.kh.statement.model.dto.PasswordDTO">
		UPDATE
		       MEMBER
		   SET
		       USERPWD = #{newPassword}
		 WHERE
		       USERID = #{userId}
		   AND
		       USERPWD = #{userPwd}
	</update><!-- #{DTO의 필드명} -->
	<!-- #은 pstmt, $은 stmt(보안에 취약) / JDBC랑 마이바티스 둘다 오래된 할아버지 기술, 옛날에 $로 썼음, 유물이 남아있을 수 있음, 보안에 취약하니까 쓰면안됨 -->
	
	<!-- 이쯤하면 Window > Show View > Outline 창이 의미가 생기지만 선생님은 별로 안쓰심 -->
	<delete id="delete"
			parameterType="member">
		DELETE
		       MEMBER
		 WHERE
		       USERID = #{userId}
		   AND
		       USERPWD = #{userPwd}
	</delete>
	
</mapper>